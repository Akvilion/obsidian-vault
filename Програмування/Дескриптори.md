Ось основні тези та найважливіші моменти зі статті про дескриптори в Python:

### **Що таке дескриптор?**
Дескриптор — це об'єкт, який визначає логіку доступу до атрибута іншого об'єкта [1]. Технічно це будь-який об'єкт, який реалізує хоча б один із методів: **`__get__`**, **`__set__`** або **`__delete__`** [1]. Коли ви звертаєтеся до атрибута (наприклад, `obj.attr`), Python запускає спеціальний протокол пошуку, і якщо атрибут є дескриптором, викликається відповідний метод [1].

### **Два типи дескрипторів**
1.  **Data descriptor**: має методи `__set__` та/або `__delete__` [2]. Вони мають **вищий пріоритет**, ніж звичайні атрибути в словнику екземпляра (`__dict__`) [2].
2.  **Non-data descriptor**: має лише метод `__get__` [2]. Вони поступаються атрибутам екземпляра за пріоритетом [2]. Прикладом є звичайні методи класу [3].

---

### **Найважливіші приклади використання**

#### **1. Валідація атрибутів (Data Descriptor)**
Це один із найпопулярніших сценаріїв. Замість того, щоб писати однакову перевірку для кожного поля через `@property`, можна створити один універсальний дескриптор [4, 5].

```python
class PositiveNumber:
    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, obj, objtype=None):
        if obj is None: return self
        return obj.__dict__.get(self.name)

    def __set__(self, obj, value):
        if value <= 0:
            raise ValueError(f"{self.name} must be positive")
        obj.__dict__[self.name] = value

class Product:
    price = PositiveNumber()
    quantity = PositiveNumber()

    def __init__(self, price, quantity):
        self.price = price
        self.quantity = quantity

p = Product(100, 5)
p.price = -10  # Викличе ValueError [4]
```

#### **2. Ледачі обчислення з кешуванням (Non-data Descriptor)**
Це дозволяє обчислити значення лише один раз при першому зверненні, а потім брати його з кешу [6].

```python
class cached_property:
    def __init__(self, func):
        self.func = func
        self.attrname = None

    def __set_name__(self, owner, name):
        self.attrname = name

    def __get__(self, obj, objtype=None):
        if obj is None: return self
        # Додаємо результат у __dict__ екземпляра
        value = self.func(obj)
        obj.__dict__[self.attrname] = value
        return value

class DataProcessor:
    @cached_property
    def heavy_data(self):
        print("Complex calculations...")
        return [i for i in range(1000)]
```
При першому виклику спрацює `__get__`, але оскільки це non-data дескриптор, після запису результату в `obj.__dict__` наступні звернення йтимуть напряму до словника, ігноруючи дескриптор [7].

---

### **Важливі нюанси та типові помилки**

*   **Метод `__set_name__`**: З'явився в Python 3.6. Він автоматично отримує ім'я атрибута, під яким дескриптор збережений у класі, що позбавляє від необхідності передавати це ім'я вручну [5, 8].
*   **Де зберігати дані?**: Дані **не можна зберігати в самому дескрипторі** (наприклад, у `self.value`), оскільки дескриптор — це атрибут класу, спільний для всіх його екземплярів [9]. Дані мають зберігатися в `obj.__dict__` самого об'єкта [9].
*   **Доступ через клас**: При зверненні `MyClass.attr` аргумент `obj` у методі `__get__` буде дорівнювати `None`. Це потрібно обробляти, зазвичай повертаючи сам об'єкт дескриптора [9, 10].

### **Коли варто використовувати?**
Джерела радять використовувати дескриптори, якщо у вас є **логіка, що повторюється** (валідація, логування, кешування) у багатьох класах або атрибутах [11]. Якщо логіка потрібна лише для одного атрибута в одному класі — краще використовувати стандартний `@property` [10, 11].